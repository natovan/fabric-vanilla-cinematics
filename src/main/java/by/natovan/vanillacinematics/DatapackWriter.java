package by.natovan.vanillacinematics;

import by.natovan.vanillacinematics.sequence.Node;
import by.natovan.vanillacinematics.sequence.NodeSequence;
import com.mojang.logging.LogUtils;
import net.minecraft.client.MinecraftClient;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.WorldSavePath;
import org.apache.commons.io.FileUtils;
import org.slf4j.Logger;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

// todo: write to tmp files first
public class DatapackWriter {
    public static final DatapackWriter INSTANCE = new DatapackWriter();
    private static final Logger LOGGER = LogUtils.getLogger();
    private boolean wasInitiated = false;
    private static final String VC_FUNC_PATH = "\\" + VanillaCinematics.CAMEL_MODID +
            "\\data\\" + VanillaCinematics.UNDERSCORE_MODID + "\\functions\\";
    private static final String VC_TAGS_FUNC_PATH = "\\" + VanillaCinematics.CAMEL_MODID +
            "\\data\\" + VanillaCinematics.UNDERSCORE_MODID + "\\tags\\functions\\";
    private static final String MC_TAGS_FUNC_PATH =
            "\\" + VanillaCinematics.CAMEL_MODID + "\\data\\minecraft\\tags\\functions\\";
    private static final String VC_MODID = VanillaCinematics.UNDERSCORE_MODID;
    private static final String VC_CAMEL = VanillaCinematics.CAMEL_MODID;
    private static final String VC_CAMEL_SPACED = VanillaCinematics.CAMEL_SPACED_MODID;

    public void initDatapack() {
        MinecraftServer server = MinecraftClient.getInstance().getServer();
        if (server == null) return;
        String datapacksPath = server.getSavePath(WorldSavePath.DATAPACKS).toString();

        try {
            Files.createDirectories(Paths.get(datapacksPath + MC_TAGS_FUNC_PATH));
            File tickFile = new File(datapacksPath + MC_TAGS_FUNC_PATH + "tick.json");
            File loadFile = new File(datapacksPath + MC_TAGS_FUNC_PATH + "load.json");
            File packFile = new File(datapacksPath + "\\" + VC_CAMEL + "\\pack.mcmeta");
            Files.createDirectories(Paths.get(datapacksPath + VC_FUNC_PATH + "cinematics"));
            File loadMcFuncFile = new File(datapacksPath + VC_FUNC_PATH + "load.mcfunction");
            File mainMcFuncFile = new File(datapacksPath + VC_FUNC_PATH + "main.mcfunction");
            if (tickFile.createNewFile() &&
                    loadFile.createNewFile() &&
                    packFile.createNewFile() &&
                    loadMcFuncFile.createNewFile() &&
                    mainMcFuncFile.createNewFile()) {
                LOGGER.info("Initial datapack files created");
            } else {
                LOGGER.info("Some initial datapack files already exist. That's fine");
            }

            FileWriter packWriter = new FileWriter(datapacksPath +
                    "\\" + VC_CAMEL + "\\pack.mcmeta");
            packWriter.write("{" +
                    "\"pack\":{" +
                    "\"pack_format\": 3, " +
                    "\"description\":" + "\"Auto generated by " + VC_CAMEL_SPACED + " mod\"}}");
            packWriter.close();

            FileWriter tickWriter = new FileWriter(datapacksPath + MC_TAGS_FUNC_PATH + "tick.json");
            tickWriter.write("{\"values\":[\"" + VC_MODID + ":main\"]}");
            tickWriter.close();

            FileWriter loadWriter = new FileWriter(datapacksPath + MC_TAGS_FUNC_PATH + "load.json");
            loadWriter.write("{\"values\":[\"" + VC_MODID + ":load\"]}");
            loadWriter.close();

            FileWriter mainFuncWriter = new FileWriter(datapacksPath + VC_FUNC_PATH + "main.mcfunction");
            mainFuncWriter.write("execute if score @a[limit=1] in_sequence matches 1 run " +
                    "spectate @e[tag=current_sequence_node, limit=1] @a[limit=1]\n");
            mainFuncWriter.close();

            FileWriter loadFuncWriter = new FileWriter(datapacksPath + VC_FUNC_PATH + "load.mcfunction");
            loadFuncWriter.write("tellraw @a " +
                    "{\"text\":\"" + VC_CAMEL_SPACED + " datapack loaded\",\"color\":\"#FFD866\"}");
            loadFuncWriter.close();
        } catch (IOException e) {
            LOGGER.error("An error occurred while writing to datapack", e);
        }
        wasInitiated = true;
    }

    public int writeSequence(NodeSequence s) {
        if (!wasInitiated) initDatapack();

        final MinecraftServer server = MinecraftClient.getInstance().getServer();
        if (server == null) return 0;
        final String datapacksPath = server.getSavePath(WorldSavePath.DATAPACKS).toString();
        final String seqName = s.getSequenceName();

        try {
            // create folder for cinematic
            Files.createDirectories(Paths.get(datapacksPath + VC_FUNC_PATH + "cinematics\\" + seqName));

            // start.mcfunction
            File startMcFuncFile = new File(datapacksPath + VC_FUNC_PATH +
                    "cinematics\\" + seqName + "\\start.mcfunction");
            if (startMcFuncFile.createNewFile()) {
                LOGGER.info(seqName + "\\start.mcfunction created");
            } else {
                LOGGER.warn(seqName + "\\start.mcfunction already exists");
            }
            FileWriter startMcFuncWriter = new FileWriter(datapacksPath + VC_FUNC_PATH +
                    "cinematics\\" + seqName + "\\start.mcfunction");
            startMcFuncWriter.write(
                    """
                    execute at @a run summon minecraft:area_effect_cloud ~ ~ ~ {Tags:['sequence_%1$s', 'sequence_node_player_pos'], Radius:0, Duration:216374}
                    execute at @a run summon minecraft:area_effect_cloud ~ ~ ~ {Tags:['sequence_%1$s', 'sequence_node_player_looking_at'], Radius:0, Duration:216374}
                    execute at @a run tp @e[tag=sequence_%1$s, tag=sequence_node_player_looking_at] ^ ^ ^4
                    gamemode spectator @a
                    scoreboard objectives add in_sequence dummy
                    scoreboard players set @a[limit=1] in_sequence 1
                    function %2$s:cinematics/%1$s/node0""".
                    formatted(seqName, VC_MODID));
            startMcFuncWriter.close();

            // nodes
            int nodeIndex = 0;
            for (; nodeIndex < s.getCameraNodes().size(); nodeIndex++) {
                // Create node mcfunction
                File nodeMcFuncFile = new File(datapacksPath + VC_FUNC_PATH +
                        "cinematics\\" + seqName + "\\node" + nodeIndex + ".mcfunction");
                if (nodeMcFuncFile.createNewFile()) {
                    LOGGER.info(seqName + "\\node " + nodeIndex + ".mcfunction created");
                } else {
                    LOGGER.warn(seqName + "\\node" + nodeIndex + ".mcfunction already exists");
                }


                // Write to node mcfunction file

                FileWriter nodeWriter = new FileWriter(datapacksPath + VC_FUNC_PATH +
                        "cinematics\\" + seqName + "\\node" + nodeIndex + ".mcfunction");
                if (nodeIndex > 0) {
                    // Remove tag from previus node entity
                    nodeWriter.write("tag @e[tag=sequence_node_%d] remove current_sequence_node\n".
                            formatted(nodeIndex - 1));
                }
                // Summon current node entity
                Node n = s.getCameraNodes().get(nodeIndex);
                nodeWriter.write(("summon minecraft:armor_stand %f %f %f " +
                        "{Rotation:[%ff, %ff], Invisible:1, NoGravity:1," +
                        " Tags:['sequence_%s', 'sequence_node_%d', 'current_sequence_node']}\n").
                        formatted(n.getStandPos().x, n.getStandPos().y, n.getStandPos().z,
                                n.getYaw(), n.getPitch(), seqName, nodeIndex));
                // And spectate it
                nodeWriter.write("spectate @e[tag=current_sequence_node, limit=1] @a[limit=1]\n");
                if (n.getCommand() != null) {
                    // Execute node command if present
                    nodeWriter.write(n.getCommand() + "\n");
                }
                if (nodeIndex > 0) {
                    // Remove previus node entity
                    nodeWriter.write("kill @e[tag=sequence_%s, tag=sequence_node_%d]\n".
                            formatted(seqName, nodeIndex - 1));
                }
                if (nodeIndex == s.getCameraNodes().size() - 1){
                    // If last, direct to end mcfunction
                    nodeWriter.write("schedule function " + VC_MODID + ":cinematics/%s/end %dt".
                            formatted(seqName, n.getDelay()));
                } else {
                    // If not last, direct to next node
                    nodeWriter.write("schedule function " + VC_MODID + ":cinematics/%s/node%d %dt".
                            formatted(seqName, nodeIndex + 1, n.getDelay()));
                }
                nodeWriter.close();
            }


            // end.mcfunction

            File endMcFuncFile = new File(datapacksPath + VC_FUNC_PATH +
                    "cinematics\\" + seqName + "\\end.mcfunction");
            if (endMcFuncFile.createNewFile()) {
                LOGGER.info(seqName + "\\end.mcfunction created");
            } else {
                LOGGER.warn(seqName + "\\end.mcfunction already exist");
            }
            FileWriter endWriter = new FileWriter(datapacksPath + VC_FUNC_PATH +
                    "cinematics\\" + seqName + "\\end.mcfunction");
            endWriter.write(
                """
                kill @e[tag=sequence_%1$s, tag=sequence_node_%2$d]
                scoreboard objectives remove in_sequence
                execute at @a run tp @a @e[tag=sequence_%s, tag=sequence_node_player_pos, limit=1]
                execute at @a run tp @a ~ ~ ~ facing entity @e[tag=sequence_%1$s, tag=sequence_node_player_looking_at, limit=1]
                gamemode adventure @a
                kill @e[tag=sequence_%1$s, tag=sequence_node_player_pos]
                kill @e[tag=sequence_%1$s, tag=sequence_node_player_looking_at]""".
                formatted(seqName, nodeIndex - 1));
            endWriter.close();
        } catch (IOException e) {
            LOGGER.error("An error occurred while writing sequence " + seqName + " to datapack", e);
            return 0;
        }
        return 1;
    }

    public void deleteDatapack() {
        MinecraftServer server = MinecraftClient.getInstance().getServer();
        if (server != null) {
            String datapacksPath = server.getSavePath(WorldSavePath.DATAPACKS).toString();
            try {
                FileUtils.deleteDirectory(new File(datapacksPath + "\\" + VC_CAMEL));
                wasInitiated = false;
                LOGGER.info("Datapack deleted");
            } catch (IOException e) {
                LOGGER.error("An error occurred while deleting datapack", e);
            }
        }
    }
}
