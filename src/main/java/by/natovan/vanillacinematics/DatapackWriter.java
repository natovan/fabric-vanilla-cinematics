package by.natovan.vanillacinematics;

import by.natovan.vanillacinematics.sequence.Node;
import by.natovan.vanillacinematics.sequence.NodeSequence;
import com.mojang.logging.LogUtils;
import net.minecraft.client.MinecraftClient;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.WorldSavePath;
import net.minecraft.util.math.Vec3d;
import org.slf4j.Logger;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

// todo: write to tmp files first
// todo: this whole thing NEEDS refactor
public class DatapackWriter {
    public static final DatapackWriter INSTANCE = new DatapackWriter();
    private static final Logger LOGGER = LogUtils.getLogger();
    private static final String VC_FUNC_PATH = "\\" + VanillaCinematics.CAMEL_MODID +
            "\\data\\" + VanillaCinematics.UNDERSCORE_MODID + "\\functions\\";
    private static final String VC_TAGS_FUNC_PATH = "\\" + VanillaCinematics.CAMEL_MODID +
            "\\data\\" + VanillaCinematics.UNDERSCORE_MODID + "\\tags\\functions\\";
    private static final String MC_TAGS_FUNC_PATH =
            "\\" + VanillaCinematics.CAMEL_MODID + "\\data\\minecraft\\tags\\functions\\";
    private static final String VC_MODID = VanillaCinematics.UNDERSCORE_MODID;
    private static final String VC_CAMEL = VanillaCinematics.CAMEL_MODID;
    private static final String VC_CAMEL_SPACED = VanillaCinematics.CAMEL_SPACED_MODID;

    public void initDatapack() {
        MinecraftServer server = MinecraftClient.getInstance().getServer();
        if (server == null) return;
        String datapacksPath = server.getSavePath(WorldSavePath.DATAPACKS).toString();

        try {
            Files.createDirectories(Paths.get(datapacksPath + MC_TAGS_FUNC_PATH));
            File tickFile = new File(datapacksPath + MC_TAGS_FUNC_PATH + "tick.json");
            File loadFile = new File(datapacksPath + MC_TAGS_FUNC_PATH + "load.json");
            File packFile = new File(datapacksPath + "\\" + VC_CAMEL + "\\pack.mcmeta");
            Files.createDirectories(Paths.get(datapacksPath + VC_FUNC_PATH + "cinematics"));
            File loadMcFuncFile = new File(datapacksPath + VC_FUNC_PATH + "load.mcfunction");
            File mainMcFuncFile = new File(datapacksPath + VC_FUNC_PATH + "main.mcfunction");
            if (tickFile.createNewFile() &&
                    loadFile.createNewFile() &&
                    packFile.createNewFile() &&
                    loadMcFuncFile.createNewFile() &&
                    mainMcFuncFile.createNewFile()) {
                LOGGER.info("Initial datapack files created");
            } else {
                LOGGER.info("Some initial datapack files already exist. That's fine");
            }

            FileWriter packWriter = new FileWriter(datapacksPath +
                    "\\" + VC_CAMEL + "\\pack.mcmeta");
            packWriter.write("{" +
                    "\"pack\":{" +
                    "\"pack_format\": 3, " +
                    "\"description\":" + "\"Auto generated by " + VC_CAMEL_SPACED + " mod\"}}");
            packWriter.close();

            FileWriter tickWriter = new FileWriter(datapacksPath + MC_TAGS_FUNC_PATH + "tick.json");
            tickWriter.write("{\"values\":[\"" + VC_MODID + ":main\"]}");
            tickWriter.close();

            FileWriter loadWriter = new FileWriter(datapacksPath + MC_TAGS_FUNC_PATH + "load.json");
            loadWriter.write("{\"values\":[\"" + VC_MODID + ":load\"]}");
            loadWriter.close();

            FileWriter mainFuncWriter = new FileWriter(datapacksPath + VC_FUNC_PATH + "main.mcfunction");
            mainFuncWriter.write("execute if score @a[limit=1] in_sequence matches 1 run " +
                    "spectate @e[tag=current_sequence_node, limit=1] @a[limit=1]\n");
            mainFuncWriter.close();

            FileWriter loadFuncWriter = new FileWriter(datapacksPath + VC_FUNC_PATH + "load.mcfunction");
            loadFuncWriter.write("tellraw @a " +
                    "{\"text\":\"" + VC_CAMEL_SPACED + " datapack loaded\",\"color\":\"#FFD866\"}");
            loadFuncWriter.close();
        } catch (IOException e) {
            LOGGER.error("An error occurred while writing to datapack", e);
        }
    }

    public int writeSequence(NodeSequence s) {
        initDatapack();

        final MinecraftServer server = MinecraftClient.getInstance().getServer();
        if (server == null) return 0;
        final String datapacksPath = server.getSavePath(WorldSavePath.DATAPACKS).toString();
        final String seqName = s.getSequenceName();

        try {
            // create folder for cinematic
            Files.createDirectories(Paths.get(datapacksPath + VC_FUNC_PATH + "cinematics\\" + seqName));

            // main.mcfunction
            FileWriter mainFuncWriter = new FileWriter(datapacksPath + VC_FUNC_PATH + "main.mcfunction", true);
            mainFuncWriter.write("execute if score @a[limit=1] in_sequence_%s matches 1 run function vanilla_cinematics:cinematics/%s/repeat\n".formatted(seqName, seqName));
            mainFuncWriter.close();


            // start.mcfunction
            File startMcFuncFile = new File(datapacksPath + VC_FUNC_PATH +
                    "cinematics\\" + seqName + "\\start.mcfunction");
            if (startMcFuncFile.createNewFile()) {
                LOGGER.info(seqName + "\\start.mcfunction created");
            } else {
                LOGGER.warn(seqName + "\\start.mcfunction already exists");
            }
            FileWriter startMcFuncWriter = new FileWriter(datapacksPath + VC_FUNC_PATH +
                    "cinematics\\" + seqName + "\\start.mcfunction");
            startMcFuncWriter.write(
                    """
                    execute at @a run summon minecraft:area_effect_cloud ~ ~ ~ {Tags:['sequence_%1$s', 'sequence_node_player_pos'], Radius:0, Duration:216374}
                    execute at @a run summon minecraft:area_effect_cloud ~ ~ ~ {Tags:['sequence_%1$s', 'sequence_node_player_looking_at'], Radius:0, Duration:216374}
                    execute at @a run tp @e[tag=sequence_%1$s, tag=sequence_node_player_looking_at] ^ ^ ^4
                    gamemode spectator @a
                    scoreboard objectives add in_sequence_%1$s dummy
                    scoreboard players set @a[limit=1] in_sequence_%1$s 1
                    scoreboard objectives add in_sequence dummy
                    scoreboard players set @a[limit=1] in_sequence 1
                    function %2$s:cinematics/%1$s/node0""".
                    formatted(seqName, VC_MODID));
            startMcFuncWriter.close();


            // repeat.mcfunction
            File repeatMcFuncFile = new File(datapacksPath + VC_FUNC_PATH +
                    "cinematics\\" + seqName + "\\repeat.mcfunction");
            if (repeatMcFuncFile.createNewFile()) {
                LOGGER.info(seqName + "\\repeat.mcfunction created");
            } else {
                LOGGER.warn(seqName + "\\repeat.mcfunction already exists");
            }
            FileWriter repeatMcFuncWriter = new FileWriter(datapacksPath + VC_FUNC_PATH +
                    "cinematics\\" + seqName + "\\repeat.mcfunction");


            // nodes
            for (int nodeIndex = 0; nodeIndex < s.getCameraNodes().size(); nodeIndex++) {


                // Write to node.mcfunction and repeat.mcfunction

                // Create node.mcfunction
                File nodeMcFuncFile = new File(datapacksPath + VC_FUNC_PATH +
                        "cinematics\\" + seqName + "\\node" + nodeIndex + ".mcfunction");
                if (nodeMcFuncFile.createNewFile()) {
                    LOGGER.info(seqName + "\\node " + nodeIndex + ".mcfunction created");
                } else {
                    LOGGER.warn(seqName + "\\node" + nodeIndex + ".mcfunction already exists");
                }

                FileWriter nodeWriter = new FileWriter(datapacksPath + VC_FUNC_PATH +
                        "cinematics\\" + seqName + "\\node" + nodeIndex + ".mcfunction");
                Node n = s.getCameraNodes().get(nodeIndex);

                if (nodeIndex > 0) {
                    // Kill prev node entity
                    nodeWriter.write("kill @e[tag=sequence_%s, tag=sequence_node_%d]\n".
                            formatted(seqName, nodeIndex - 1));
                    // If prev node had smooth trans score - remove it
                    nodeWriter.write("execute if score @a[limit=1] node_%d_smooth_trans matches 1 run scoreboard objectives remove node_%d_smooth_trans\n".formatted(nodeIndex - 1, nodeIndex - 1));
                }

                // If smooth add repeating command to repeat.mcfunction and create scoreboard objective node
                if (n.getSmooth()) {
                    if (s.getCameraNodes().size() - 1 > nodeIndex)  {
                        Node next = s.getCameraNodes().get(nodeIndex + 1);
                        String offset = getPositionOffset(n.getStandPos(), next.getStandPos(), n.getDelay());
                        repeatMcFuncWriter.write("execute if score @a[limit=1] node_%d_smooth_trans matches 1 at @e[tag=current_sequence_node] run tp @e[tag=current_sequence_node] %s\n".formatted(nodeIndex, offset));
                        nodeWriter.write("scoreboard objectives add node_%d_smooth_trans dummy\n".formatted(nodeIndex));
                        nodeWriter.write("scoreboard players set @a[limit=1] node_%d_smooth_trans 1\n".formatted(nodeIndex));
                    } else {
                        LOGGER.warn("Smooth flag at last node, ignoring");
                    }
                }

                // Summon current node entity
                nodeWriter.write(("summon minecraft:armor_stand %f %f %f " +
                        "{Rotation:[%ff, %ff], Invisible:1, NoGravity:1," +
                        " Tags:['sequence_%s', 'sequence_node_%d', 'current_sequence_node']}\n").
                        formatted(n.getStandPos().x, n.getStandPos().y, n.getStandPos().z,
                                n.getYaw(), n.getPitch(), seqName, nodeIndex));
                // And spectate it
                nodeWriter.write("spectate @e[tag=current_sequence_node, limit=1] @a[limit=1]\n");
                if (n.getCommand() != null) // Execute node command if present
                    nodeWriter.write(n.getCommand() + "\n");

                final byte tickDelay = 3; // Needed since node entity starts moving a little late for some reason
                if (nodeIndex == s.getCameraNodes().size() - 1) { // If last, direct to end mcfunction
                    nodeWriter.write("schedule function " + VC_MODID + ":cinematics/%s/end %dt".
                            formatted(seqName, n.getDelay()  + tickDelay));
                } else { // If not last, direct to next node
                    nodeWriter.write("schedule function " + VC_MODID + ":cinematics/%s/node%d %dt".
                            formatted(seqName, nodeIndex + 1, n.getDelay() + tickDelay));
                }
                nodeWriter.close();
            }
            repeatMcFuncWriter.close();


            // end.mcfunction

            File endMcFuncFile = new File(datapacksPath + VC_FUNC_PATH +
                    "cinematics\\" + seqName + "\\end.mcfunction");
            if (endMcFuncFile.createNewFile()) {
                LOGGER.info(seqName + "\\end.mcfunction created");
            } else {
                LOGGER.warn(seqName + "\\end.mcfunction already exist");
            }
            FileWriter endWriter = new FileWriter(datapacksPath + VC_FUNC_PATH +
                    "cinematics\\" + seqName + "\\end.mcfunction");
            endWriter.write(
                """
                kill @e[tag=sequence_%1$s, tag=sequence_node_%2$d]
                scoreboard objectives remove in_sequence
                scoreboard objectives remove in_sequence_%1$s
                execute at @a run tp @a @e[tag=sequence_%s, tag=sequence_node_player_pos, limit=1]
                execute at @a run tp @a ~ ~ ~ facing entity @e[tag=sequence_%1$s, tag=sequence_node_player_looking_at, limit=1]
                gamemode adventure @a
                kill @e[tag=sequence_%1$s, tag=sequence_node_player_pos]
                kill @e[tag=sequence_%1$s, tag=sequence_node_player_looking_at]""".
                formatted(seqName, s.getCameraNodes().size() - 1));
            endWriter.close();
        } catch (IOException e) {
            LOGGER.error("An error occurred while writing sequence " + seqName + " to datapack", e);
            return 0;
        }
        return 1;
    }

    private static String getPositionOffset(Vec3d from, Vec3d to, int delay) {
        double xDist = from.x - to.x;
        double yDist = from.y - to.y;
        double zDist = from.z - to.z;
        if (xDist < 0) xDist = -xDist;
        if (yDist < 0) yDist = -yDist;
        if (zDist < 0) zDist = -zDist;

        if (from.x > to.x) xDist = -xDist;
        if (from.y > to.y) yDist = -yDist;
        if (from.z > to.z) zDist = -zDist;

        double xOffset = xDist / delay;
        double yOffset = yDist / delay;
        double zOffset = zDist / delay;

        return "~%f ~%f ~%f".formatted(xOffset, yOffset, zOffset);
    }
}
